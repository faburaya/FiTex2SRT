using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace FiTex2SRT.Engine
{
    /// <summary>
    /// Holds the text and the scarce synchronization that have been read
    /// from an audio transcript generated by a human.
    /// </summary>
    public class Transcript
    {
        public string Text { get; private init; }

        public SortedDictionary<int, TimeSpan> SyncTimes { get; private init; }

        private Transcript(string text, SortedDictionary<int, TimeSpan> syncTimes)
        {
            Text = text;
            SyncTimes = syncTimes;
        }

        private static TimeSpan ParseTime(string timestamp)
        {
            int[] parts = (from s in timestamp.Split(':') select int.Parse(s)).ToArray();
            Debug.Assert(parts.Length == 4);
            return new TimeSpan(0, parts[0], parts[1], parts[2], parts[3] * 10);

        }

        private readonly static Regex _timeRegex =
            new(@"^(?<start>[\d]{2}:[\d]{2}:[\d]{2}:[\d]{2}) - (?<end>[\d]{2}:[\d]{2}:[\d]{2}:[\d]{2})",
                RegexOptions.Compiled | RegexOptions.Multiline);

        /// <summary>
        /// Parses the transcript.
        /// </summary>
        /// <param name="rawText">The raw text of the transcription.</param>
        /// <returns>The parsed transcription as a <see cref="Transcript"/> object.</returns>
        public static Transcript Parse(string rawText)
        {
            List<(int idxPrevEnd, int idxStart, TimeSpan startTime, TimeSpan endTime)> paragraphs = new();

            MatchCollection matches = _timeRegex.Matches(rawText);
            foreach (Match match in matches)
            {
                paragraphs.Add((
                    match.Index,
                    match.Index + match.Length + 1,
                    ParseTime(match.Groups["start"].Value),
                    ParseTime(match.Groups["end"].Value)
                ));
            }

            SortedDictionary<int, TimeSpan> syncTimes = new();
            StringBuilder buffer = new();
            for (int idx = 0; idx < paragraphs.Count; ++idx)
            {
                syncTimes.Add(buffer.Length, paragraphs[idx].startTime);
                int idxStart = paragraphs[idx].idxStart;
                int idxEnd = (idx + 1 < paragraphs.Count ? paragraphs[idx + 1].idxPrevEnd : rawText.Length);
                buffer.Append(rawText.AsSpan(idxStart, idxEnd - idxStart));
                syncTimes.Add(buffer.Length - 1, paragraphs[idx].endTime);
            }

            return new Transcript(buffer.ToString(), syncTimes);
        }
    }
}
